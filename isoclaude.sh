#!/bin/bash
# IsoClaude - Isolated Ubuntu Desktop for Claude Development
# Usage: ./isoclaude.sh <command> [options]

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
COMPOSE_FILE="$SCRIPT_DIR/docker-compose.yml"
PROJECTS_CONF="$SCRIPT_DIR/projects.conf"
CONTAINER_NAME="iso-claude-ubuntu"

# Colors
BOLD='\033[1m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
CYAN='\033[0;36m'
RED='\033[0;31m'
RESET='\033[0m'

# --- Compose generation ---

conf_changed() {
    if [[ ! -f "$COMPOSE_FILE" ]]; then
        return 0
    fi
    if [[ ! -f "$PROJECTS_CONF" ]]; then
        return 1
    fi
    [[ "$PROJECTS_CONF" -nt "$COMPOSE_FILE" ]]
}

auto_regenerate() {
    if conf_changed; then
        echo -e "${YELLOW}Detected changes in projects.conf, regenerating...${RESET}"
        generate_compose
        # Restart container if running to apply changes
        if docker ps --format '{{.Names}}' | grep -q "^${CONTAINER_NAME}$"; then
            echo -e "${YELLOW}Restarting container to apply changes...${RESET}"
            docker compose -f "$COMPOSE_FILE" down
            docker compose -f "$COMPOSE_FILE" up -d
        fi
    fi
}

generate_compose() {
    echo "Generating docker-compose.yml from projects.conf..."

    # Parse projects first (handles migration if needed)
    parse_projects

    cat > "$COMPOSE_FILE" << 'HEADER'
# Auto-generated by isoclaude.sh - do not edit manually
# Edit projects.conf and run: ./isoclaude.sh regenerate

services:
  iso-claude-ubuntu:
    image: lscr.io/linuxserver/webtop:ubuntu-kde
    container_name: iso-claude-ubuntu
    ports:
      - "3000:3000"       # Desktop
      - "2222:22"         # SSH
      - "8090:8080"       # Python/NiceGUI HTTP
      - "8453:8443"       # Python/NiceGUI HTTPS
      - "8511:8501"       # Streamlit
      - "3010:3001"       # Node.js alternate
      - "5010:5000"       # Flask
    volumes:
      - ubuntu-config:/config
      - ubuntu-usr:/usr
      - ubuntu-opt:/opt
      - ubuntu-var:/var
      - ubuntu-root:/root
      - ./scripts/setup-container.sh:/setup-container.sh:ro
HEADER

    local volume_count=0
    for i in "${!PROJECT_NAMES[@]}"; do
        local name="${PROJECT_NAMES[$i]}"
        local host_path="${PROJECT_HOST_PATHS[$i]}"
        local git="${PROJECT_GIT[$i]}"

        echo "      # Project: $name" >> "$COMPOSE_FILE"
        echo "      - $host_path:/projects/$name" >> "$COMPOSE_FILE"
        if [[ "$git" == "false" ]]; then
            echo "      - git-exclude-$volume_count:/projects/$name/.git" >> "$COMPOSE_FILE"
            ((volume_count++))
        fi
    done

    cat >> "$COMPOSE_FILE" << 'VOLUMES'
    shm_size: "2gb"
    restart: unless-stopped

volumes:
  ubuntu-config:
  ubuntu-usr:
  ubuntu-opt:
  ubuntu-var:
  ubuntu-root:
VOLUMES

    for ((i=0; i<volume_count; i++)); do
        echo "  git-exclude-$i:" >> "$COMPOSE_FILE"
    done

    echo "Generated $COMPOSE_FILE"
}

# --- Container management ---

check_container() {
    if ! docker ps --format '{{.Names}}' | grep -q "^${CONTAINER_NAME}$"; then
        echo -e "${YELLOW}Container not running. Starting...${RESET}"
        cmd_up
        echo -n "Waiting for container"
        for i in {1..30}; do
            if docker ps --format '{{.Names}}' | grep -q "^${CONTAINER_NAME}$"; then
                echo -e " ${GREEN}ready${RESET}"
                return 0
            fi
            echo -n "."
            sleep 1
        done
        echo -e "\n${RED}Error: Container failed to start${RESET}"
        exit 1
    fi
}

cmd_up() {
    auto_regenerate
    [[ ! -f "$COMPOSE_FILE" ]] && generate_compose
    docker compose -f "$COMPOSE_FILE" up -d
    echo ""
    echo "Ubuntu Desktop: http://localhost:3000"
    echo "Run './isoclaude.sh setup' to install dev tools (first time only)"
}

cmd_down() {
    docker compose -f "$COMPOSE_FILE" down
}

cmd_setup() {
    echo "Installing development tools in container..."
    docker exec "$CONTAINER_NAME" /setup-container.sh
}

cmd_regenerate() {
    generate_compose
    # Restart container if running to apply changes
    if docker ps --format '{{.Names}}' | grep -q "^${CONTAINER_NAME}$"; then
        echo -e "${YELLOW}Restarting container to apply changes...${RESET}"
        docker compose -f "$COMPOSE_FILE" down
        docker compose -f "$COMPOSE_FILE" up -d
        echo -e "${GREEN}Done.${RESET}"
    else
        echo "Changes will apply when container starts."
    fi
}

cmd_browser() {
    local url="${1:-http://localhost:3000}"
    echo "Opening $url..."
    if [[ "$OSTYPE" == "darwin"* ]]; then
        open "$url"
    elif [[ "$OSTYPE" == "linux-gnu"* ]]; then
        xdg-open "$url" 2>/dev/null || sensible-browser "$url"
    elif [[ "$OSTYPE" == "msys" || "$OSTYPE" == "cygwin" ]]; then
        start "$url"
    else
        echo "Please open $url in your browser"
    fi
}

# --- Config format detection and migration ---

is_old_format() {
    [[ ! -f "$PROJECTS_CONF" ]] && return 1
    # Old format has lines like "/path/to/project:true"
    # TOML format has lines like "[ProjectName]" or "key = value"
    while IFS= read -r line || [[ -n "$line" ]]; do
        [[ "$line" =~ ^#.*$ || -z "$line" ]] && continue
        # If line starts with [ or contains =, it's TOML
        if [[ "$line" =~ ^\[.*\]$ ]] || [[ "$line" =~ = ]]; then
            return 1
        fi
        # If line matches /path:bool pattern, it's old format
        if [[ "$line" =~ ^/.+:(true|false)$ ]]; then
            return 0
        fi
    done < "$PROJECTS_CONF"
    return 1
}

migrate_config() {
    echo -e "${YELLOW}Migrating projects.conf to TOML format...${RESET}"
    local temp_file="$PROJECTS_CONF.new"

    cat > "$temp_file" << 'EOF'
# IsoClaude Project Configuration (TOML format)
#
# Format:
# [ProjectName]
# path = /full/path/to/project
# git = true|false
#
# Example:
# [MyApp]
# path = /Users/someone/projects/MyApp
# git = false

EOF

    while IFS= read -r line || [[ -n "$line" ]]; do
        [[ "$line" =~ ^#.*$ || -z "$line" ]] && continue
        local path="${line%%:*}"
        local include_git="${line##*:}"
        local folder_name="$(basename "$path")"

        cat >> "$temp_file" << EOF
[$folder_name]
path = $path
git = $include_git

EOF
    done < "$PROJECTS_CONF"

    mv "$PROJECTS_CONF" "$PROJECTS_CONF.old"
    mv "$temp_file" "$PROJECTS_CONF"
    echo -e "${GREEN}Migration complete.${RESET} Old config saved as projects.conf.old"
}

check_and_migrate() {
    if is_old_format; then
        migrate_config
    fi
}

# --- Project detection ---

declare -a PROJECT_NAMES
declare -a PROJECT_PATHS
declare -a PROJECT_GIT
declare -a PROJECT_CHROME
declare -a PROJECT_HOST_PATHS

parse_projects() {
    PROJECT_NAMES=()
    PROJECT_PATHS=()
    PROJECT_GIT=()
    PROJECT_CHROME=()
    PROJECT_HOST_PATHS=()

    [[ ! -f "$PROJECTS_CONF" ]] && return

    # Check and migrate old format
    check_and_migrate

    local idx=0
    local current_name=""
    local current_path=""
    local current_git="false"
    local current_chrome="false"

    while IFS= read -r line || [[ -n "$line" ]]; do
        # Skip comments and empty lines
        [[ "$line" =~ ^[[:space:]]*#.*$ || -z "${line// }" ]] && continue

        # Section header [ProjectName]
        if [[ "$line" =~ ^\[(.+)\]$ ]]; then
            # Save previous project if complete
            if [[ -n "$current_name" && -n "$current_path" ]]; then
                PROJECT_NAMES[$idx]="$current_name"
                PROJECT_PATHS[$idx]="/projects/$current_name"
                PROJECT_GIT[$idx]="$current_git"
                PROJECT_CHROME[$idx]="$current_chrome"
                PROJECT_HOST_PATHS[$idx]="$current_path"
                ((idx++))
            fi
            current_name="${BASH_REMATCH[1]}"
            current_path=""
            current_git="false"
            current_chrome="false"
            continue
        fi

        # Key = value pairs
        if [[ "$line" =~ ^[[:space:]]*([^=]+)[[:space:]]*=[[:space:]]*(.+)$ ]]; then
            local key="${BASH_REMATCH[1]}"
            local value="${BASH_REMATCH[2]}"
            # Trim whitespace
            key="${key%% }"
            key="${key## }"
            value="${value%% }"
            value="${value## }"

            case "$key" in
                path) current_path="$value" ;;
                git) current_git="$value" ;;
                chrome) current_chrome="$value" ;;
            esac
        fi
    done < "$PROJECTS_CONF"

    # Save last project
    if [[ -n "$current_name" && -n "$current_path" ]]; then
        PROJECT_NAMES[$idx]="$current_name"
        PROJECT_PATHS[$idx]="/projects/$current_name"
        PROJECT_GIT[$idx]="$current_git"
        PROJECT_CHROME[$idx]="$current_chrome"
        PROJECT_HOST_PATHS[$idx]="$current_path"
    fi
}

detect_project() {
    local arg="$1"
    local cwd="$(pwd)"
    PROJECT_IDX=-1

    for i in "${!PROJECT_HOST_PATHS[@]}"; do
        local host_path="${PROJECT_HOST_PATHS[$i]}"
        local folder_name="${PROJECT_NAMES[$i]}"
        local container_path="${PROJECT_PATHS[$i]}"

        if [[ -n "$arg" ]]; then
            if [[ "$arg" == "$folder_name" || "$arg" == "$host_path" || "$arg" == "$container_path" ]]; then
                PROJECT_IDX=$i
                return 0
            fi
        elif [[ "$cwd" == "$host_path" || "$cwd" == "$host_path"/* ]]; then
            PROJECT_IDX=$i
            return 0
        fi
    done
    return 1
}

# --- Interactive selection ---

arrow_select() {
    local title="$1"
    shift
    local items=("$@")
    local count=${#items[@]}
    local current=0

    tput civis
    trap 'tput cnorm' RETURN

    while true; do
        tput clear
        echo ""
        echo -e "${BOLD}$title${RESET}"
        echo -e "${CYAN}Use ↑/↓ arrows, Enter to select${RESET}"
        echo ""

        for i in "${!items[@]}"; do
            if [[ $i -eq $current ]]; then
                echo -e "  ${GREEN}▶ ${items[$i]}${RESET}"
            else
                echo -e "    ${items[$i]}"
            fi
        done

        read -rsn1 key
        if [[ "$key" == $'\x1b' ]]; then
            read -rsn2 key
            case "$key" in
                '[A') ((current--)); [[ $current -lt 0 ]] && current=$((count - 1)) ;;
                '[B') ((current++)); [[ $current -ge $count ]] && current=0 ;;
            esac
        elif [[ "$key" == "" ]]; then
            SELECTED_IDX=$current
            tput cnorm
            tput clear
            return
        fi
    done
}

select_project_interactive() {
    if [[ ${#PROJECT_NAMES[@]} -eq 0 ]]; then
        echo -e "${RED}No projects configured.${RESET}"
        echo "Add one with: ./isoclaude.sh projects:add /path/to/project"
        return 1
    fi

    if [[ ${#PROJECT_NAMES[@]} -eq 1 ]]; then
        PROJECT_IDX=0
        return 0
    fi

    local items=()
    for i in "${!PROJECT_NAMES[@]}"; do
        local git_status chrome_status
        if [[ "${PROJECT_GIT[$i]}" == "true" ]]; then
            git_status="${GREEN}git${RESET}"
        else
            git_status="${YELLOW}no-git${RESET}"
        fi
        if [[ "${PROJECT_CHROME[$i]}" == "true" ]]; then
            chrome_status="${CYAN}chrome${RESET}"
        else
            chrome_status=""
        fi
        local status_str="$git_status"
        [[ -n "$chrome_status" ]] && status_str="$status_str $chrome_status"
        items+=("$(printf "%-25s %s" "${PROJECT_NAMES[$i]}" "$status_str")")
    done

    arrow_select "Select Project" "${items[@]}"
    PROJECT_IDX=$SELECTED_IDX
}

resolve_project() {
    parse_projects
    if detect_project "$1"; then
        return 0
    elif [[ -n "$1" ]]; then
        echo -e "${RED}Error: Project not found: $1${RESET}"
        echo "Run './isoclaude.sh projects:list' to see configured projects"
        return 1
    else
        select_project_interactive
    fi
}

select_mode() {
    local items=(
        "Normal mode (safe)"
        "${RED}Dangerous mode (--dangerously-skip-permissions)${RESET}"
    )
    arrow_select "Select Launch Mode" "${items[@]}"
    if [[ $SELECTED_IDX -eq 0 ]]; then
        CLAUDE_MODE=""
    else
        CLAUDE_MODE="--dangerously-skip-permissions"
    fi
}

# --- Project management ---

ensure_projects_conf() {
    if [[ ! -f "$PROJECTS_CONF" ]]; then
        echo "Creating projects.conf..."
        cat > "$PROJECTS_CONF" << 'EOF'
# IsoClaude Project Configuration (TOML format)
#
# Format:
# [ProjectName]
# path = /full/path/to/project
# git = true|false
# chrome = true|false
#
# Example:
# [MyApp]
# path = /Users/someone/projects/MyApp
# git = false
# chrome = true

EOF
    fi
}

cmd_projects_list() {
    if [[ ! -f "$PROJECTS_CONF" ]]; then
        echo "No projects.conf found. Add a project with:"
        echo "  isoclaude projects:add /path/to/project"
        return 0
    fi

    parse_projects

    if [[ ${#PROJECT_NAMES[@]} -eq 0 ]]; then
        echo "No projects configured."
        echo ""
        echo "Add a project with:"
        echo "  isoclaude projects:add /path/to/project"
        return 0
    fi

    echo "Configured projects:"
    echo ""
    for i in "${!PROJECT_NAMES[@]}"; do
        local name="${PROJECT_NAMES[$i]}"
        local host_path="${PROJECT_HOST_PATHS[$i]}"
        local git="${PROJECT_GIT[$i]}"
        local chrome="${PROJECT_CHROME[$i]}"

        echo "  $name"
        echo "    Path:   $host_path"
        echo "    Git:    $([ "$git" == "true" ] && echo "on" || echo "off")"
        echo "    Chrome: $([ "$chrome" == "true" ] && echo "on" || echo "off")"
        echo ""
    done

    echo "Total: ${#PROJECT_NAMES[@]} project(s)"
}

cmd_projects_add() {
    local path=""
    local include_git=""
    local include_chrome=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --git)
                if [[ "$2" == "true" || "$2" == "false" ]]; then
                    include_git="$2"
                    shift 2
                else
                    echo -e "${RED}Error: --git requires 'true' or 'false'${RESET}"
                    return 1
                fi
                ;;
            --chrome)
                if [[ "$2" == "true" || "$2" == "false" ]]; then
                    include_chrome="$2"
                    shift 2
                else
                    echo -e "${RED}Error: --chrome requires 'true' or 'false'${RESET}"
                    return 1
                fi
                ;;
            -*)
                echo -e "${RED}Error: Unknown option: $1${RESET}"
                return 1
                ;;
            *)
                if [[ -z "$path" ]]; then
                    path="$1"
                else
                    echo -e "${RED}Error: Multiple paths specified${RESET}"
                    return 1
                fi
                shift
                ;;
        esac
    done

    if [[ -z "$path" ]]; then
        echo "Usage: isoclaude projects:add <path> [--git true|false] [--chrome true|false]"
        echo ""
        echo "Examples:"
        echo "  isoclaude projects:add ~/projects/MyApp"
        echo "  isoclaude projects:add ~/projects/MyApp --git true"
        echo "  isoclaude projects:add ~/projects/MyApp --chrome true"
        echo "  isoclaude projects:add ~/projects/MyApp --git true --chrome true"
        return 1
    fi

    if [[ ! -d "$path" ]]; then
        echo -e "${RED}Error: Directory does not exist: $path${RESET}"
        return 1
    fi

    path="$(cd "$path" && pwd)"
    folder_name="$(basename "$path")"

    ensure_projects_conf
    check_and_migrate

    # Check if project exists and get current settings
    parse_projects
    local exists=false
    local old_git=""
    local old_chrome=""
    local existing_idx=-1

    for i in "${!PROJECT_NAMES[@]}"; do
        if [[ "${PROJECT_HOST_PATHS[$i]}" == "$path" ]]; then
            exists=true
            old_git="${PROJECT_GIT[$i]}"
            old_chrome="${PROJECT_CHROME[$i]}"
            existing_idx=$i
            break
        fi
    done

    # For new projects, default git=false, chrome=true; for existing, keep current if not specified
    if [[ "$exists" == "true" ]]; then
        [[ -z "$include_git" ]] && include_git="$old_git"
        [[ -z "$include_chrome" ]] && include_chrome="$old_chrome"
    else
        [[ -z "$include_git" ]] && include_git="false"
        [[ -z "$include_chrome" ]] && include_chrome="true"
    fi

    # Rebuild config file in TOML format
    local temp_file="$PROJECTS_CONF.tmp"

    # Write header
    cat > "$temp_file" << 'EOF'
# IsoClaude Project Configuration (TOML format)
#
# Format:
# [ProjectName]
# path = /full/path/to/project
# git = true|false
# chrome = true|false
#
# Example:
# [MyApp]
# path = /Users/someone/projects/MyApp
# git = false
# chrome = true

EOF

    # Write existing projects (skip the one being updated)
    for i in "${!PROJECT_NAMES[@]}"; do
        if [[ $i -ne $existing_idx ]]; then
            cat >> "$temp_file" << EOF
[${PROJECT_NAMES[$i]}]
path = ${PROJECT_HOST_PATHS[$i]}
git = ${PROJECT_GIT[$i]}
chrome = ${PROJECT_CHROME[$i]}

EOF
        fi
    done

    # Add the new/updated project
    cat >> "$temp_file" << EOF
[$folder_name]
path = $path
git = $include_git
chrome = $include_chrome

EOF

    mv "$temp_file" "$PROJECTS_CONF"

    # Report changes
    local changes=()
    if [[ "$exists" == "true" ]]; then
        [[ "$old_git" != "$include_git" ]] && changes+=("Git: $([ "$old_git" == "true" ] && echo "on" || echo "off") -> $([ "$include_git" == "true" ] && echo "on" || echo "off")")
        [[ "$old_chrome" != "$include_chrome" ]] && changes+=("Chrome: $([ "$old_chrome" == "true" ] && echo "on" || echo "off") -> $([ "$include_chrome" == "true" ] && echo "on" || echo "off")")

        if [[ ${#changes[@]} -gt 0 ]]; then
            echo -e "${GREEN}Updated project: $folder_name${RESET}"
            for change in "${changes[@]}"; do
                echo "  $change"
            done
        else
            echo -e "${YELLOW}Project unchanged: $folder_name${RESET}"
            echo "  Git: $([ "$include_git" == "true" ] && echo "on" || echo "off"), Chrome: $([ "$include_chrome" == "true" ] && echo "on" || echo "off")"
        fi
    else
        echo -e "${GREEN}Added project: $folder_name${RESET}"
        echo "  Path:   $path"
        echo "  Git:    $([ "$include_git" == "true" ] && echo "on" || echo "off")"
        echo "  Chrome: $([ "$include_chrome" == "true" ] && echo "on" || echo "off")"
    fi
    echo ""
    echo "Changes will auto-apply on next command (claude, bash, code, etc.)"
}

cmd_projects_remove() {
    local target="$1"

    if [[ -z "$target" ]]; then
        echo "Usage: isoclaude projects:remove <path|name>"
        return 1
    fi

    if [[ ! -f "$PROJECTS_CONF" ]]; then
        echo "Error: No projects.conf found"
        return 1
    fi

    check_and_migrate
    parse_projects

    local found=false
    local found_name=""
    local remove_idx=-1

    for i in "${!PROJECT_NAMES[@]}"; do
        local name="${PROJECT_NAMES[$i]}"
        local host_path="${PROJECT_HOST_PATHS[$i]}"

        if [[ "$host_path" == "$target" || "$name" == "$target" ]]; then
            found=true
            found_name="$name"
            remove_idx=$i
            break
        fi
    done

    if [[ "$found" != "true" ]]; then
        echo -e "${RED}Error: Project not found: $target${RESET}"
        return 1
    fi

    # Rebuild config file without the removed project
    local temp_file="$PROJECTS_CONF.tmp"

    cat > "$temp_file" << 'EOF'
# IsoClaude Project Configuration (TOML format)
#
# Format:
# [ProjectName]
# path = /full/path/to/project
# git = true|false
# chrome = true|false
#
# Example:
# [MyApp]
# path = /Users/someone/projects/MyApp
# git = false
# chrome = true

EOF

    for i in "${!PROJECT_NAMES[@]}"; do
        if [[ $i -ne $remove_idx ]]; then
            cat >> "$temp_file" << EOF
[${PROJECT_NAMES[$i]}]
path = ${PROJECT_HOST_PATHS[$i]}
git = ${PROJECT_GIT[$i]}
chrome = ${PROJECT_CHROME[$i]}

EOF
        fi
    done

    mv "$temp_file" "$PROJECTS_CONF"

    echo -e "${GREEN}Removed project: $found_name${RESET}"
    echo ""
    echo "Changes will auto-apply on next command (claude, bash, code, etc.)"
}

# --- Main commands ---

cmd_claude() {
    local extra_args=("$@")

    check_container
    parse_projects

    if detect_project ""; then
        echo -e "${GREEN}Detected project: ${BOLD}${PROJECT_NAMES[$PROJECT_IDX]}${RESET}"
    else
        select_project_interactive || exit 1
    fi

    select_mode

    local project_name="${PROJECT_NAMES[$PROJECT_IDX]}"
    local project_path="${PROJECT_PATHS[$PROJECT_IDX]}"
    local project_chrome="${PROJECT_CHROME[$PROJECT_IDX]}"

    tput clear
    echo ""
    echo -e "${GREEN}Launching Claude in ${BOLD}$project_name${RESET}${GREEN}...${RESET}"

    if [[ -n "$CLAUDE_MODE" ]]; then
        echo -e "${YELLOW}Mode: DANGEROUS (skipping permissions)${RESET}"
    else
        echo "Mode: Normal"
    fi

    # Build MCP flags
    local mcp_flags=""
    if [[ "$project_chrome" == "true" ]]; then
        mcp_flags="--mcp claude-in-chrome"
        echo -e "${CYAN}Chrome: enabled${RESET}"
    fi

    if [[ ${#extra_args[@]} -gt 0 ]]; then
        echo "Args: ${extra_args[*]}"
    fi
    echo ""

    local claude_cmd="claude $CLAUDE_MODE $mcp_flags ${extra_args[*]}"

    docker exec -it -u abc -e HOME=/config -w "$project_path" "$CONTAINER_NAME" \
        /bin/bash -c "source /etc/profile.d/poetry.sh 2>/dev/null; source ~/.bashrc 2>/dev/null; $claude_cmd"
}

cmd_bash() {
    local project="$1"
    check_container
    if resolve_project "$project"; then
        echo "Connecting to ${PROJECT_NAMES[$PROJECT_IDX]}..."
        docker exec -it -w "${PROJECT_PATHS[$PROJECT_IDX]}" "$CONTAINER_NAME" bash
    else
        [[ -z "$project" ]] && return 1
        exit 1
    fi
}

cmd_code() {
    local project="$1"
    if resolve_project "$project"; then
        echo "Opening VS Code in ${PROJECT_NAMES[$PROJECT_IDX]}..."
        code --remote ssh-remote+abc@localhost:2222 "${PROJECT_PATHS[$PROJECT_IDX]}"
    else
        [[ -z "$project" ]] && return 1
        exit 1
    fi
}

cmd_windsurf() {
    local project="$1"
    if resolve_project "$project"; then
        echo "Opening Windsurf in ${PROJECT_NAMES[$PROJECT_IDX]}..."
        windsurf --remote ssh-remote+abc@localhost:2222 "${PROJECT_PATHS[$PROJECT_IDX]}"
    else
        [[ -z "$project" ]] && return 1
        exit 1
    fi
}

cmd_help() {
    cat << HELP
IsoClaude - Isolated Ubuntu Desktop for Claude Development

Usage: isoclaude <command> [options]

Setup alias (copy & paste):
  echo 'alias isoclaude="$SCRIPT_DIR/isoclaude.sh"' >> ~/.zshrc && source ~/.zshrc
  echo 'alias isoclaude="$SCRIPT_DIR/isoclaude.sh"' >> ~/.bashrc && source ~/.bashrc

Container:
  up              Start the container
  down            Stop the container (data persists)
  setup           Install Python, Poetry, Rust, Node, Claude CLI
  regenerate      Rebuild docker-compose.yml from projects.conf
  browser [url]   Open browser (default: http://localhost:3000)

Development:
  bash [project]      Bash shell in project directory
  code [project]      VS Code remote to project
  windsurf [project]  Windsurf remote to project
  claude [args]       Launch Claude CLI (auto-detects project, asks mode)

Project Management:
  projects:list       List configured projects
  projects:add        Add a project mount
  projects:remove     Remove a project mount

Port Mappings (container -> host):
  3000 -> 3000    Desktop (noVNC)
  22   -> 2222    SSH
  8080 -> 8090    Python/NiceGUI HTTP
  8443 -> 8453    Python/NiceGUI HTTPS
  8501 -> 8511    Streamlit
  3001 -> 3010    Node.js
  5000 -> 5010    Flask

Note: bash/code/windsurf/claude auto-detect project from current directory.

Examples:
  isoclaude up                    # Start container
  isoclaude browser               # Open desktop in browser
  isoclaude setup                 # Install dev tools
  isoclaude claude                # Launch Claude (auto-detect + mode picker)
  isoclaude claude --resume       # Resume previous session
  isoclaude bash                  # Bash shell
  isoclaude code MyApp            # VS Code in specific project

  isoclaude projects:add ~/projects/MyApp
  isoclaude projects:add ~/projects/MyApp --git true      # Enable git
  isoclaude projects:add ~/projects/MyApp --chrome true   # Enable Chrome MCP
  isoclaude projects:add ~/projects/MyApp --git true --chrome true
HELP
}

# Main
case "${1:-}" in
    up) cmd_up ;;
    down) cmd_down ;;
    setup) cmd_setup ;;
    regenerate) cmd_regenerate ;;
    browser|open) cmd_browser "$2" ;;
    bash) cmd_bash "$2" ;;
    code) cmd_code "$2" ;;
    windsurf) cmd_windsurf "$2" ;;
    claude) shift; cmd_claude "$@" ;;
    projects:list) cmd_projects_list ;;
    projects:add) shift; cmd_projects_add "$@" ;;
    projects:remove) cmd_projects_remove "$2" ;;
    help|--help|-h) cmd_help ;;
    "")
        echo -e "${CYAN}Tip: Run 'isoclaude --help' for all commands${RESET}"
        echo ""
        cmd_claude
        ;;
    *) echo "Unknown command: $1"; cmd_help; exit 1 ;;
esac
