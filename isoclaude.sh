#!/bin/bash
# IsoClaude - Isolated Ubuntu Desktop for Claude Development
# Usage: ./isoclaude.sh <command> [options]

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
COMPOSE_FILE="$SCRIPT_DIR/docker-compose.yml"
PROJECTS_CONF="$SCRIPT_DIR/projects.conf"
CONTAINER_NAME="iso-claude-ubuntu"

# Colors
BOLD='\033[1m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
CYAN='\033[0;36m'
RED='\033[0;31m'
RESET='\033[0m'

# --- Compose generation ---

conf_changed() {
    if [[ ! -f "$COMPOSE_FILE" ]]; then
        return 0
    fi
    if [[ ! -f "$PROJECTS_CONF" ]]; then
        return 1
    fi
    [[ "$PROJECTS_CONF" -nt "$COMPOSE_FILE" ]]
}

auto_regenerate() {
    if conf_changed; then
        echo -e "${YELLOW}Detected changes in projects.conf, regenerating...${RESET}"
        generate_compose
        # Restart container if running to apply changes
        if docker ps --format '{{.Names}}' | grep -q "^${CONTAINER_NAME}$"; then
            echo -e "${YELLOW}Restarting container to apply changes...${RESET}"
            docker compose -f "$COMPOSE_FILE" down
            docker compose -f "$COMPOSE_FILE" up -d
        fi
    fi
}

generate_compose() {
    echo "Generating docker-compose.yml from projects.conf..."

    cat > "$COMPOSE_FILE" << 'HEADER'
# Auto-generated by isoclaude.sh - do not edit manually
# Edit projects.conf and run: ./isoclaude.sh regenerate

services:
  iso-claude-ubuntu:
    image: lscr.io/linuxserver/webtop:ubuntu-kde
    container_name: iso-claude-ubuntu
    ports:
      - "3000:3000"       # Desktop
      - "2222:22"         # SSH
      - "8090:8080"       # Python/NiceGUI HTTP
      - "8453:8443"       # Python/NiceGUI HTTPS
      - "8511:8501"       # Streamlit
      - "3010:3001"       # Node.js alternate
      - "5010:5000"       # Flask
    volumes:
      - ubuntu-config:/config
      - ubuntu-usr:/usr
      - ubuntu-opt:/opt
      - ubuntu-var:/var
      - ubuntu-root:/root
      - ./scripts/setup-container.sh:/setup-container.sh:ro
HEADER

    local volume_count=0
    while IFS= read -r line || [[ -n "$line" ]]; do
        [[ "$line" =~ ^#.*$ || -z "$line" ]] && continue
        path="${line%%:*}"
        include_git="${line##*:}"
        folder_name="$(basename "$path")"
        echo "      # Project: $folder_name" >> "$COMPOSE_FILE"
        echo "      - $path:/projects/$folder_name" >> "$COMPOSE_FILE"
        if [[ "$include_git" == "false" ]]; then
            echo "      - git-exclude-$volume_count:/projects/$folder_name/.git" >> "$COMPOSE_FILE"
            ((volume_count++))
        fi
    done < "$PROJECTS_CONF"

    cat >> "$COMPOSE_FILE" << 'VOLUMES'
    shm_size: "2gb"
    restart: unless-stopped

volumes:
  ubuntu-config:
  ubuntu-usr:
  ubuntu-opt:
  ubuntu-var:
  ubuntu-root:
VOLUMES

    for ((i=0; i<volume_count; i++)); do
        echo "  git-exclude-$i:" >> "$COMPOSE_FILE"
    done

    echo "Generated $COMPOSE_FILE"
}

# --- Container management ---

check_container() {
    if ! docker ps --format '{{.Names}}' | grep -q "^${CONTAINER_NAME}$"; then
        echo -e "${YELLOW}Container not running. Starting...${RESET}"
        cmd_up
        echo -n "Waiting for container"
        for i in {1..30}; do
            if docker ps --format '{{.Names}}' | grep -q "^${CONTAINER_NAME}$"; then
                echo -e " ${GREEN}ready${RESET}"
                return 0
            fi
            echo -n "."
            sleep 1
        done
        echo -e "\n${RED}Error: Container failed to start${RESET}"
        exit 1
    fi
}

cmd_up() {
    auto_regenerate
    [[ ! -f "$COMPOSE_FILE" ]] && generate_compose
    docker compose -f "$COMPOSE_FILE" up -d
    echo ""
    echo "Ubuntu Desktop: http://localhost:3000"
    echo "Run './isoclaude.sh setup' to install dev tools (first time only)"
}

cmd_down() {
    docker compose -f "$COMPOSE_FILE" down
}

cmd_setup() {
    echo "Installing development tools in container..."
    docker exec "$CONTAINER_NAME" /setup-container.sh
}

cmd_regenerate() {
    generate_compose
    # Restart container if running to apply changes
    if docker ps --format '{{.Names}}' | grep -q "^${CONTAINER_NAME}$"; then
        echo -e "${YELLOW}Restarting container to apply changes...${RESET}"
        docker compose -f "$COMPOSE_FILE" down
        docker compose -f "$COMPOSE_FILE" up -d
        echo -e "${GREEN}Done.${RESET}"
    else
        echo "Changes will apply when container starts."
    fi
}

cmd_browser() {
    local url="${1:-http://localhost:3000}"
    echo "Opening $url..."
    if [[ "$OSTYPE" == "darwin"* ]]; then
        open "$url"
    elif [[ "$OSTYPE" == "linux-gnu"* ]]; then
        xdg-open "$url" 2>/dev/null || sensible-browser "$url"
    elif [[ "$OSTYPE" == "msys" || "$OSTYPE" == "cygwin" ]]; then
        start "$url"
    else
        echo "Please open $url in your browser"
    fi
}

# --- Project detection ---

declare -a PROJECT_NAMES
declare -a PROJECT_PATHS
declare -a PROJECT_GIT
declare -a PROJECT_HOST_PATHS

parse_projects() {
    PROJECT_NAMES=()
    PROJECT_PATHS=()
    PROJECT_GIT=()
    PROJECT_HOST_PATHS=()

    [[ ! -f "$PROJECTS_CONF" ]] && return

    local idx=0
    while IFS= read -r line || [[ -n "$line" ]]; do
        [[ "$line" =~ ^#.*$ || -z "$line" ]] && continue
        local path="${line%%:*}"
        local include_git="${line##*:}"
        local folder_name="$(basename "$path")"
        PROJECT_NAMES[$idx]="$folder_name"
        PROJECT_PATHS[$idx]="/projects/$folder_name"
        PROJECT_GIT[$idx]="$include_git"
        PROJECT_HOST_PATHS[$idx]="$path"
        ((idx++))
    done < "$PROJECTS_CONF"
}

detect_project() {
    local arg="$1"
    local cwd="$(pwd)"
    PROJECT_IDX=-1

    for i in "${!PROJECT_HOST_PATHS[@]}"; do
        local host_path="${PROJECT_HOST_PATHS[$i]}"
        local folder_name="${PROJECT_NAMES[$i]}"
        local container_path="${PROJECT_PATHS[$i]}"

        if [[ -n "$arg" ]]; then
            if [[ "$arg" == "$folder_name" || "$arg" == "$host_path" || "$arg" == "$container_path" ]]; then
                PROJECT_IDX=$i
                return 0
            fi
        elif [[ "$cwd" == "$host_path" || "$cwd" == "$host_path"/* ]]; then
            PROJECT_IDX=$i
            return 0
        fi
    done
    return 1
}

# --- Interactive selection ---

arrow_select() {
    local title="$1"
    shift
    local items=("$@")
    local count=${#items[@]}
    local current=0

    tput civis
    trap 'tput cnorm' RETURN

    while true; do
        tput clear
        echo ""
        echo -e "${BOLD}$title${RESET}"
        echo -e "${CYAN}Use ↑/↓ arrows, Enter to select${RESET}"
        echo ""

        for i in "${!items[@]}"; do
            if [[ $i -eq $current ]]; then
                echo -e "  ${GREEN}▶ ${items[$i]}${RESET}"
            else
                echo -e "    ${items[$i]}"
            fi
        done

        read -rsn1 key
        if [[ "$key" == $'\x1b' ]]; then
            read -rsn2 key
            case "$key" in
                '[A') ((current--)); [[ $current -lt 0 ]] && current=$((count - 1)) ;;
                '[B') ((current++)); [[ $current -ge $count ]] && current=0 ;;
            esac
        elif [[ "$key" == "" ]]; then
            SELECTED_IDX=$current
            tput cnorm
            tput clear
            return
        fi
    done
}

select_project_interactive() {
    if [[ ${#PROJECT_NAMES[@]} -eq 0 ]]; then
        echo -e "${RED}No projects configured.${RESET}"
        echo "Add one with: ./isoclaude.sh projects:add /path/to/project"
        return 1
    fi

    if [[ ${#PROJECT_NAMES[@]} -eq 1 ]]; then
        PROJECT_IDX=0
        return 0
    fi

    local items=()
    for i in "${!PROJECT_NAMES[@]}"; do
        local git_status
        if [[ "${PROJECT_GIT[$i]}" == "true" ]]; then
            git_status="${GREEN}git:connected${RESET}"
        else
            git_status="${YELLOW}git:isolated${RESET}"
        fi
        items+=("$(printf "%-25s %s" "${PROJECT_NAMES[$i]}" "$git_status")")
    done

    arrow_select "Select Project" "${items[@]}"
    PROJECT_IDX=$SELECTED_IDX
}

resolve_project() {
    parse_projects
    if detect_project "$1"; then
        return 0
    elif [[ -n "$1" ]]; then
        echo -e "${RED}Error: Project not found: $1${RESET}"
        echo "Run './isoclaude.sh projects:list' to see configured projects"
        return 1
    else
        select_project_interactive
    fi
}

select_mode() {
    local items=(
        "Normal mode (safe)"
        "${RED}Dangerous mode (--dangerously-skip-permissions)${RESET}"
    )
    arrow_select "Select Launch Mode" "${items[@]}"
    if [[ $SELECTED_IDX -eq 0 ]]; then
        CLAUDE_MODE=""
    else
        CLAUDE_MODE="--dangerously-skip-permissions"
    fi
}

# --- Project management ---

ensure_projects_conf() {
    if [[ ! -f "$PROJECTS_CONF" ]]; then
        echo "Creating projects.conf..."
        cat > "$PROJECTS_CONF" << 'EOF'
# IsoClaude Project Mounts Configuration
# Format: /path/to/project:include_git (true/false)
# Projects are mounted to /projects/<folder_name> in the container

EOF
    fi
}

cmd_projects_list() {
    if [[ ! -f "$PROJECTS_CONF" ]]; then
        echo "No projects.conf found. Add a project with:"
        echo "  ./isoclaude.sh projects:add /path/to/project"
        return 0
    fi

    local count=0
    echo "Configured projects:"
    echo ""
    while IFS= read -r line || [[ -n "$line" ]]; do
        [[ "$line" =~ ^#.*$ || -z "$line" ]] && continue
        path="${line%%:*}"
        include_git="${line##*:}"
        folder_name="$(basename "$path")"
        if [[ "$include_git" == "true" ]]; then
            git_status="(with .git)"
        else
            git_status="(no .git)"
        fi
        echo "  $folder_name"
        echo "    Path: $path"
        echo "    Git:  $git_status"
        echo ""
        ((count++))
    done < "$PROJECTS_CONF"

    if [[ $count -eq 0 ]]; then
        echo "  No projects configured."
        echo ""
        echo "Add a project with:"
        echo "  ./isoclaude.sh projects:add /path/to/project"
    else
        echo "Total: $count project(s)"
    fi
}

cmd_projects_add() {
    local path="$1"
    local include_git="${2:-false}"

    if [[ -z "$path" ]]; then
        echo "Usage: ./isoclaude.sh projects:add <path> [include_git]"
        echo ""
        echo "Examples:"
        echo "  ./isoclaude.sh projects:add ~/projects/MyApp"
        echo "  ./isoclaude.sh projects:add ~/projects/OSS true"
        return 1
    fi

    if [[ ! -d "$path" ]]; then
        echo "Error: Directory does not exist: $path"
        return 1
    fi

    path="$(cd "$path" && pwd)"

    if [[ "$include_git" != "true" && "$include_git" != "false" ]]; then
        echo "Error: include_git must be 'true' or 'false'"
        return 1
    fi

    ensure_projects_conf

    while IFS= read -r line || [[ -n "$line" ]]; do
        [[ "$line" =~ ^#.*$ || -z "$line" ]] && continue
        existing_path="${line%%:*}"
        if [[ "$existing_path" == "$path" ]]; then
            echo "Error: Project already configured: $path"
            return 1
        fi
    done < "$PROJECTS_CONF"

    echo "$path:$include_git" >> "$PROJECTS_CONF"
    folder_name="$(basename "$path")"
    echo -e "${GREEN}Added project: $folder_name${RESET}"
    echo "  Path: $path"
    echo "  Git:  $([ "$include_git" == "true" ] && echo "included" || echo "excluded")"
    echo ""
    echo "Changes will auto-apply on next command (claude, bash, code, etc.)"
}

cmd_projects_remove() {
    local target="$1"

    if [[ -z "$target" ]]; then
        echo "Usage: ./isoclaude.sh projects:remove <path|name>"
        return 1
    fi

    if [[ ! -f "$PROJECTS_CONF" ]]; then
        echo "Error: No projects.conf found"
        return 1
    fi

    local found=0
    local temp_file="$PROJECTS_CONF.tmp"

    while IFS= read -r line || [[ -n "$line" ]]; do
        if [[ "$line" =~ ^#.*$ || -z "$line" ]]; then
            echo "$line" >> "$temp_file"
            continue
        fi
        path="${line%%:*}"
        folder_name="$(basename "$path")"
        if [[ "$path" == "$target" || "$folder_name" == "$target" ]]; then
            found=1
            echo "Removed project: $folder_name"
        else
            echo "$line" >> "$temp_file"
        fi
    done < "$PROJECTS_CONF"

    mv "$temp_file" "$PROJECTS_CONF"

    if [[ $found -eq 0 ]]; then
        echo -e "${RED}Error: Project not found: $target${RESET}"
        return 1
    fi
    echo ""
    echo "Changes will auto-apply on next command (claude, bash, code, etc.)"
}

# --- Main commands ---

cmd_claude() {
    local extra_args=("$@")

    check_container
    parse_projects

    if detect_project ""; then
        echo -e "${GREEN}Detected project: ${BOLD}${PROJECT_NAMES[$PROJECT_IDX]}${RESET}"
    else
        select_project_interactive || exit 1
    fi

    select_mode

    local project_name="${PROJECT_NAMES[$PROJECT_IDX]}"
    local project_path="${PROJECT_PATHS[$PROJECT_IDX]}"

    tput clear
    echo ""
    echo -e "${GREEN}Launching Claude in ${BOLD}$project_name${RESET}${GREEN}...${RESET}"

    if [[ -n "$CLAUDE_MODE" ]]; then
        echo -e "${YELLOW}Mode: DANGEROUS (skipping permissions)${RESET}"
    else
        echo "Mode: Normal"
    fi

    if [[ ${#extra_args[@]} -gt 0 ]]; then
        echo "Args: ${extra_args[*]}"
    fi
    echo ""

    local claude_cmd="claude $CLAUDE_MODE ${extra_args[*]}"

    docker exec -it -u abc -e HOME=/config -w "$project_path" "$CONTAINER_NAME" \
        /bin/bash -c "source /etc/profile.d/poetry.sh 2>/dev/null; source ~/.bashrc 2>/dev/null; $claude_cmd"
}

cmd_bash() {
    local project="$1"
    check_container
    if resolve_project "$project"; then
        echo "Connecting to ${PROJECT_NAMES[$PROJECT_IDX]}..."
        docker exec -it -w "${PROJECT_PATHS[$PROJECT_IDX]}" "$CONTAINER_NAME" bash
    else
        [[ -z "$project" ]] && return 1
        exit 1
    fi
}

cmd_code() {
    local project="$1"
    if resolve_project "$project"; then
        echo "Opening VS Code in ${PROJECT_NAMES[$PROJECT_IDX]}..."
        code --remote ssh-remote+abc@localhost:2222 "${PROJECT_PATHS[$PROJECT_IDX]}"
    else
        [[ -z "$project" ]] && return 1
        exit 1
    fi
}

cmd_windsurf() {
    local project="$1"
    if resolve_project "$project"; then
        echo "Opening Windsurf in ${PROJECT_NAMES[$PROJECT_IDX]}..."
        windsurf --remote ssh-remote+abc@localhost:2222 "${PROJECT_PATHS[$PROJECT_IDX]}"
    else
        [[ -z "$project" ]] && return 1
        exit 1
    fi
}

cmd_help() {
    cat << HELP
IsoClaude - Isolated Ubuntu Desktop for Claude Development

Usage: isoclaude <command> [options]

Setup alias (copy & paste):
  echo 'alias isoclaude="$SCRIPT_DIR/isoclaude.sh"' >> ~/.zshrc && source ~/.zshrc
  echo 'alias isoclaude="$SCRIPT_DIR/isoclaude.sh"' >> ~/.bashrc && source ~/.bashrc

Container:
  up              Start the container
  down            Stop the container (data persists)
  setup           Install Python, Poetry, Rust, Node, Claude CLI
  regenerate      Rebuild docker-compose.yml from projects.conf
  browser [url]   Open browser (default: http://localhost:3000)

Development:
  bash [project]      Bash shell in project directory
  code [project]      VS Code remote to project
  windsurf [project]  Windsurf remote to project
  claude [args]       Launch Claude CLI (auto-detects project, asks mode)

Project Management:
  projects:list       List configured projects
  projects:add        Add a project mount
  projects:remove     Remove a project mount

Port Mappings (container -> host):
  3000 -> 3000    Desktop (noVNC)
  22   -> 2222    SSH
  8080 -> 8090    Python/NiceGUI HTTP
  8443 -> 8453    Python/NiceGUI HTTPS
  8501 -> 8511    Streamlit
  3001 -> 3010    Node.js
  5000 -> 5010    Flask

Note: bash/code/windsurf/claude auto-detect project from current directory.

Examples:
  isoclaude up                    # Start container
  isoclaude browser               # Open desktop in browser
  isoclaude setup                 # Install dev tools
  isoclaude claude                # Launch Claude (auto-detect + mode picker)
  isoclaude claude --resume       # Resume previous session
  isoclaude bash                  # Bash shell
  isoclaude code MyApp            # VS Code in specific project

  isoclaude projects:add ~/projects/MyApp
  isoclaude projects:add ~/projects/OSS true  # Include .git
HELP
}

# Main
case "${1:-help}" in
    up) cmd_up ;;
    down) cmd_down ;;
    setup) cmd_setup ;;
    regenerate) cmd_regenerate ;;
    browser|open) cmd_browser "$2" ;;
    bash) cmd_bash "$2" ;;
    code) cmd_code "$2" ;;
    windsurf) cmd_windsurf "$2" ;;
    claude) shift; cmd_claude "$@" ;;
    projects:list) cmd_projects_list ;;
    projects:add) cmd_projects_add "$2" "$3" ;;
    projects:remove) cmd_projects_remove "$2" ;;
    help|--help|-h) cmd_help ;;
    *) echo "Unknown command: $1"; cmd_help; exit 1 ;;
esac
